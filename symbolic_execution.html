<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="kmdtty.css">
<title>Symbolic Execution</title>
<script src="kmdtty_mathjax_setting.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="container">
<h1>Notes on Symbolic Execution</h1>
<h2>1. Introduction</h2>
<p>
<b>Symbolic Execution</b> is a technique to verify computer programms.
Let me start to talk about a small example to explain what is Symbolic Execution.
</p>
<pre>
int foo(int x, int y) {
    int t = 0;
    if x &gt; y {
        t = x;
    } else {
        t = y;
    }
    assert(t &lt; x);
    return t;
}
</pre>
<p>
This C function foo() checks $t < x$ before returing the value t, but how we assure if it is True? 
</p>
<p>
One way is a test. Call foo() with some test values,
</p>
<dl>
<dt>x = 3, y = 4</dt> <dd>$=$ foo(3, 4) $\Rightarrow$ t = y = 4 $\Rightarrow t < x = \text{False}$</dd>
<!--
<dt>x = 0, y = 0</dt> <dd>foo(0, 0)</dd>
<dt>x = -2147483648, y = -2147483648</dt><dd>foo(-2147483648, -2147483648)</dd>
<dt>x = -2147483648, y = 2147483648</dt><dd>foo(-2147483648, 2147483648)</dd>
-->
<dt>...</dt><dd></dd>
</dl>
<p>
However this single test result does not tells other test values behaivier, and
the range of C int is $[-2147483648, 2147483648]$, so if we test all the int ranges, it becomes $(2147483648 \times 2) \times (2147483648 \times 2)$ cases.
</p>
<p<p>
To deal with this issue, we introduce abstract variable $X, Y$ instead of tesiting concrete int values for x and y.
</p>
<p>
Here, let $X,Y$ be the given variable of x, y respectively. Then,
</p>
<pre>
if x > y {
  t = x;
} else {
  t = y;
}
</pre>
<p>
This C code can be expressed as the following logical expression with the abstract variable $X,Y$.
</p>
<p>
$(X > Y \implies t = X) \wedge (\neg (X > Y) \implies t = Y)$
</p>
<!--
<p>
\[
t =
 \begin{cases}
  X & (X>Y) \\
  Y & (\text{otherwise})
 \end{cases}
\]
</p>
-->
<p>
Then, asking $t < x$ becomes evaluating the following Logical expression.
</p>
<p>
$(X > Y \implies t = X) \wedge (\neg (X > Y) \implies t = Y) \wedge t < X$
</p>
<p>
(XXX: do we need to introduce a variable for $t$? where the line of assertion)
</p>
<p>
This symbolic formula allows arbitary many imputs for the variable $X,Y$, and tells how is the relationship among $x, y$ and $t$.
</p>
<p>
Here, we have to questsions to run Symblic Eecution:
</p>
<ul>
<li>How to construct the logical expression</li>
<li>How to solve or answer the logical question in a mechanical way</li>
</ul>
<p>
In the next section, we would like to address about it.
</p>

<h2>2. How to run Symbolic Execution</h2>
<div class="definition" text="Symbolic execution">
TBA
</div>
<p>
(TODO: Define language, define evaluation rule for $+,-,\times$ over integers that accepts abstract variables)
</p>
<p>
(TODO: Define path condition (pc) of IF statements. <b>pc</b> is a boolean expression over the symbolic inputs $\{\alpha_i\}$. $R \geq 0$ or $\neg(R \geq 0)$ where $R$ is a polynomial over $\{\alpha_i\}$. Each symbolic execution begins with pc initialized to true.
</p>
<p>
Prerequirement: define a subset of C language that only have $+,-,\times$ over 32bit C int values, and predicates $ =, !=, &gt;=, &gt;, &lt;=, &lt; $ and assignments to a C variables.
</p>
<h3>
symbolic execution  algorithm for a C function:
</h3>
<pre>
while (line in souce code) {
  if line is a IF statement:
    condition = evaluate(IF statement)
    if condition == True:
        continue
    else if IF has no ELSE or ELSE:
        PC = PC /\ condition
    else if IF has ELSE or ELSE IF:
        # branching
        PC_{i+1} = dup(PC)
        PC_{i+1} = PC_{i+1} /\ condition
  else if line is an assignment:
    update_environment(evaluate(line))
  else:
    skip
}
</pre>
<h2>Symbolic Execution Tree</h2>
<p>
What is symbolic execution tree?
</p>
<p>
To define execution tree, need:
</p>
<ul>
<li>statement number $\implies$ node
<li>statement transition $implies$ transition
<li>concrete values
<li>symbolic values
<li>environment
</ul>
<p>
In Automaton: $(S, s_0, P)$  state $S$, initial state $s_0$, transition set $P$.
</p>
<h3>Symbolic Execution Tree alogorithm</h3>
<pre>
state_list = [s_0]
transition_dict = {}
environment = {}
while (line in soource code) {
  previous_state = last_state(state_list)
  current_state = line_number(line)
  state_list.add(current_state)
  if line is a IF statement:
    condition = evaluate(IF statement)
    if condition == True:
       transition_dict[previous_state].append(current_state)
       continue
    else if IF has no ELSE or ELSE:
        PC = PC /\ condition
        # do we need to add state here?
        new_state = newState(state_list)
        new_state.path_condtion = PC
        transtion_dict[previous_state].append(new_state)
    else if IF has ELSE or ELSE IF:
        # branching
        PC_{i+1} = dup(PC)
        PC_{i+1} = PC_{i+1} /\ condition
        new_state = newState(state_list)
        new_state.path_condition = PC_{i+1}
        transtion_dict[previous_state].append(new_state)
  else if line is an assignment:
    environment = update_environment(evaluate(line))
  else:
    skip
}
</pre>
<p>
We have these propperties in symbolic execution tree:
<ol>
<li> There must be a concrete values that lead to the terminate node (PC). (This can be proved by how construct the PCs. PCs are added when branched this is when the both conditions are not false, so the conditions are not false and is a predicate $R$ on polynomials over integer, or $\neg R$. Both can be assigned a concrete integer)
<li> The logical expression of terminate nodes are unique. (This can be proved by how to construct the PCs. PC is either $pc_{i+1} = pc_i \wedge r$ or $pc_{i+2} = pc_i \wedge \neg r$.)
</ol>
</p>
<p>(I feel 1) and 2) are saying the same thing..?, No. We can think the both a) unique and unreachable, b) reachable and duplicated tree) </p>
<p>Again, why is symbolic tree needed?</p>
<ul>
<li>From the property 1) We can test the concrete input values (If the condition is not satisfiable, computing assignment is useless)
<li>From the property 1) We can eliminate useless testing (If it is not reachable, computing assignment is useless).
<li>From the property 2) We can eliminate duplicated logical expressions.
<li>We can imediately test PCs when the node is terminated, no need to wait untile all PCs are calculated.
</ul>
<p>
<h2>References</h2>
<ol>
<li>King, J. C. Symbolic execution and program testing. Commun. ACM 19, 385â€“394 (1976)</li>
</ol>
<hr>
<nav class="mb-3"><a href="index.html">Home</a> &gt; Symbolic Execution</nav>
</div>
</body>
</html>
