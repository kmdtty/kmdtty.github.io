<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="kmdtty.css">
<title>Symbolic Execution</title>
<script src="kmdtty_mathjax_setting.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="container">
<h1>Notes on Symbolic Execution</h1>
<h2>1. Introduction</h2>
<p>
<b>Symbolic Execution</b> is a technique to verify computer programms.
Let me start to talk about a small example to explain what is Symbolic Execution.
</p>
<pre>
int foo(int x, int y) {
    int t = 0;
    if x &gt; y {
        t = x;
    } else {
        t = y;
    }
    assert(t &lt; x);
    return t;
}
</pre>
<p>
This C function foo() checks $t < x$ before returing the value t, but how we assure if it is True? 
</p>
<p>
One way is a test. Call foo() with some test values,
</p>
<dl>
<dt>x = 3, y = 4</dt> <dd>$=$ foo(3, 4) $\Rightarrow$ t = y = 4 $\Rightarrow t < x = \text{False}$</dd>
<!--
<dt>x = 0, y = 0</dt> <dd>foo(0, 0)</dd>
<dt>x = -2147483648, y = -2147483648</dt><dd>foo(-2147483648, -2147483648)</dd>
<dt>x = -2147483648, y = 2147483648</dt><dd>foo(-2147483648, 2147483648)</dd>
-->
<dt>...</dt><dd></dd>
</dl>
<p>
However this single test result does not tells other test values behaivier, and
the range of C int is $[-2147483648, 2147483648]$, so if we test all the int ranges, it becomes $(2147483648 \times 2) \times (2147483648 \times 2)$ cases.
</p>
<p<p>
To deal with this issue, we introduce abstract variable $X, Y$ instead of tesiting concrete int values for x and y.
</p>
<p>
Here, let $X,Y$ be the given variable of x, y respectively. Then,
</p>
<pre>
if x > y {
  t = x;
} else {
  t = y;
}
</pre>
<p>
This C code can be expressed as the following logical expression with the abstract variable $X,Y$.
</p>
<p>
$(X > Y \implies t = X) \wedge (\neg (X > Y) \implies t = Y)$
</p>
<!--
<p>
\[
t =
 \begin{cases}
  X & (X>Y) \\
  Y & (\text{otherwise})
 \end{cases}
\]
</p>
-->
<p>
Then, asking $t < x$ becomes evaluating the following Logical expression.
</p>
<p>
$(X > Y \implies t = X) \wedge (\neg (X > Y) \implies t = Y) \wedge t < X$
</p>
<p>
(XXX: do we need to introduce a variable for $t$? where the line of assertion)
</p>
<p>
This symbolic formula allows arbitary many imputs for the variable $X,Y$, and tells how is the relationship among $x, y$ and $t$.
</p>
<p>
Here, we have to questsions to run Symblic Eecution:
</p>
<ul>
<li>How to construct the logical expression</li>
<li>How to solve or answer the logical question in a mechanical way</li>
</ul>
<p>
In the next section, we would like to address about it.
</p>

<h2>2. How to run Symbolic Execution</h2>
<div class="definition" text="Symbolic execution">
TBA
</div>
<blockquote>
That is, each symbolic execution result may be quivalent to a large number of normal test cases. These results can be checked agains the programmer's expectations for correctness either formally or informally.
</blockquote>
<blockquote>
The class of inputs characterized by each symbolic execution is determined by the dependence of the program's control flow on its inputs. If the control flow of the program is completely independent of the input variables, a single symbolic execution will suffice to check all possible executions of the program. If the control flow of the program is dependent on the inputs, one must resort to a case analysis. 
</blockquote>
<blockquote>
Often the set of input classes needed to exhaust all possible case is practically infinite, so this is still basically a testing methodology. However, the input classes are determined only by those inputs involved in the control flow, and symbolic testing promises to provide better results more easily than normal testing for most programs.
</blockquote>
<p>
(TODO: Define language, define evaluation rule for $+,-,\times$ over integers that accepts abstract variables)
</p>
<p>
(TODO: Define path condition (pc) of IF statements. <b>pc</b> is a boolean expression over the symbolic inputs $\{\alpha_i\}$. $R \geq 0$ or $\neg(R \geq 0)$ where $R$ is a polynomial over $\{\alpha_i\}$. Each symbolic execution begins with pc initialized to true.
</p>
<blockquote>
... each time a new input value for the program is required, it is supplied symbolically from the list of symbols [$\alpha_1, \alpha_2, \alpha_3, ...$].
</blockquote>
<p>
Prerequirement: define a subset of C language that only have $+,-,\times$ over 32bit C int values, and predicates $ =, !=, &gt;=, &gt;, &lt;=, &lt; $ and assignments to a C variables.
</p>
<p>
(a symbolic execution for a C function:
</p>
<div>
<pre>
while (line in souce code) {
  if line is a IF statement:
    condition = evaluate(IF statement)
    if condition == True:
        continue
    else if IF has no ELSE or ELSE:
        PC = PC /\ condition
    else if IF has ELSE or ELSE IF:
        # branching
        PC_{i+1} = dup(PC)
        PC_{i+1} = PC_{i+1} /\ condition
  else if line is an assignment:
    update_environment(evaluate(line))
  else:
    skip
}
</pre>
<p>
Now that you have Path Condition (PC).
</p>
<p>
(What is symbolic execution tree? Why is it needed?)
</p>
<p>
My understanding of this stetement:
<ol>
<li> There must be a concrete values that lead to the terminate node (PC).
<li> The evaluation of terminate nodes are exclusive. (This can be proved by the construction of PCs. PC is either $pc_{i+1} = pc_i \wedge r$ or $pc_{i+2} = pc_i \wedge \neg r$.)
</ol>
</p>
<p>(I feel 1) and 2) are saying the same thing..?)</p>
<p>Quotes from King (1976).</p>
<blockquote>
<ol>
<li>For each terminal leaf in the tree (corresponding to a completed execution path) there does exist a particular nonsymbolic input to the program which, when executed in the normal fashion, will trace the same path (list of stetements executed). This is equivalent to saying that <i>pc</i> never becomes identically <i>fales</i>.
<li><i>pc</i>'s associated with any two terminal leves are distinct (ie. $\neg (pc_1 \wedge pc_2)$). The two paths from the common root of the execution tree leading to any two leaves have a unique forking node where the two paths diverge. At that forking node some <i>q</i> was added to one <i>pc</i>  while $\neg q$ was added to the other. Since neither <i>pc</i> becomes incosistent (false) they must maintain this difference.
</ol>
</blockquote>
<p>
To define execution tree, need statement number, node, transition and arc, variable values?, statement counter?)
</p>
<ul>
<li>To determin what PCs are needed to check?</li>
<li>Determin all PCs are not equivalent with checking terminating node?</li>
</ul>
</div>
<h2>References</h2>
<ol>
<li>King, J. C. Symbolic execution and program testing. Commun. ACM 19, 385â€“394 (1976)</li>
</ol>
<hr>
<nav class="mb-3"><a href="index.html">Home</a> &gt; Symbolic Execution</nav>
</div>
</body>
</html>
