<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="kmdtty.css">
<title>Hoare Logic</title>
<script src="kmdtty_mathjax_setting.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="container">
<h1>Notes on Hoare Logic</h1>
<h2>1. Introduction</h2>
<p>
Hoare Logic is a logic to prove progamming languages.
</p>
<p>
For example, imagine a ALGOL like imerative program which adding two integers <code>x</code>, <code>y</code>.
</p>
<pre class="code">
z := x + y
</pre>
<p>
This program looks obvious, but if we need to prove this program behavior, how to do it? To answer this question, Hoare invented Hoare Triple in <a href="#hoare">(Hoare, 1969)</a>.
</p>
<div class="definition" text="Hoare Triple">
Hoare triple is a (P, S, Q) that is denoted:
\[\{P\}\, S\, \{Q\}\]
where $P$ is the precondition that is true before $S$ is executed, $S$ is a subset of program list, Q is the postcondition that is true after the $S$ are executed.
</div>
<p>For example, a hoare triple is formed as follows:</p>
<p>$\{x + y = 4\}$</p>
<p>
z := x + y
</p>
<p>$\{z = 4\}$</p>
<p>
Here, the precondition $P$ is $x + y = 4$, and a program $S$ is <code>z := x + y</code>, and the postcondition $Q$ is $z = 4$. 
</p>
<p>
To derive a conclusion from premises, we need a <em>deductive system</em>. Formal deductive systems are consists of <em>Axioms</em> and <em>Rule</em>. To derive $Q$ from $P$ and $S$, let's consider the axiom and rules with analyzing the programs.
</p>
<p>
When assigning a value f into variable x, <code>x=f</code>, what happened to the precondition and post condition? In Hoare Triple, we think the pre-condition from the post-condition. We are reasoning from backward. So what pre-condition we need for <code>x=f</code> $\{Q\}$? Since in $Q$, the variable <code>x</code> is replaced with <code>f</code>, the precondition $P$ must be $Q[f/x]$.
</p>
<p>
The most simple example is:
</p>
<pre class="code">
{P?}
<code>x := f</code>
{x = f}
</pre>
<p>
The the precondition $P$ must be $Q[f/x]$ so here it is $f = f$. 
</p>
<p>
With this analysis we defines the following axiom.
</p>

<div class="definition" text="Axiom of Assignment">
\begin{equation}
\frac{}{
\{ Q[\text{f/x}] \}\,\,
\text{x := f}\,\,
\{Q\}
}
\end{equation}
where <b>x</b> is a variable of a program, <b>f</b> is a expression of a program, and $Q[\text{f/x}]$ denotes a replacement all occurense of <b>f</b> in $Q$ with <b>x</b> .
</div>
<p>
Having Axiom of Assignment, now we can prove the following Hoare Triple.</p>
<p>\begin{equation*}
\{x + y = 4\} \,
\text{z := x + y;} \,
\{z = 4\}
\end{equation*}
</p>
<p>
$z = 4$ can be replaced with $(z = 4)[\text{x+y/z}]$ by Axiom of Assignment, then we immediately get $ x + y = 4$.
<span class="qed">$\Box$</span>
</p>
<p>
Likewise, we define these deductive rules. Before defining all the remaining rules, we first need the the target programming language specification.
</p>
<div class="definition" text="Target Programming Language">
\begin{array}{lll}
&e :=& x \mid n  \mid e + e \mid e * e\\
&b :=& \text{true } \mid \text{ false } \mid e \lt e \mid e \gt e \mid e == e \mid \text{not } b \mid b \text{ and } b \mid b \text{ or } b \\
&s :=& \text{skip } \mid \, s;s \mid x = e \mid \text{ if b then $c$ else $c$} 
\end{array}
<p>
where x is a meta charactor of variables, n is a meta charactor of number, s is programs.
</p>
</div>
<p>
With the above syntax all those are programs:
</p>
<ul>
<li><code>if x &gt; y then y = x else x = y</code>
<li><code>skip; skip; skip</code>
<li><code>x := 1; y := x + 2; z := y + 3</code>
</ul>
<p>
Now we have defined the syntax of target program. Next, we defines all remaining rules.
</p>
<div class="definition" text="Concate Rule">
\begin{equation}
\frac{
\{P\} A \{P_1\} \, \, \, \, \,
\{P_1\} B \{Q\}
}{
\{ P \} \,
\text{A; B} \,
\{ Q \}
}
\end{equation}
</div>
<div class="definition" text="If Rule">
\begin{equation}
\frac{
  \{ b \wedge P\}  s_1 \{ Q\} \, \, \, \, \, \, \,
  \{ \neg b \wedge P\}  s_2 \{ Q\}
  }
  {
\{ P \}  \, \,
\text{if (b) \{$s_1$\} else \{ $s_2$ \}  } \, \,
\{ Q \}
}
\end{equation}
</div>
<div class="definition" text="Consequence Rule">
\begin{equation}
\frac{\models P_0 \implies P \, \, \, \, \,
\models Q_0 \implies Q \, \, \, \, \,
\{ P_0 \} S \{ Q_0\}
}
{\{ P \} S \{ Q\}}
\end{equation}
</div>
<!--
<div class="definition" text="Loop Rule">
\begin{equation}
(TBA)
\end{equation}
</div>
-->
<p>
Example:
</p>
<p>
Let a hoare triple be, $\{x = 3\}$ y := x + 2; z := y + 4  $\{z = 3x\}$, a proof with Hoare Logic is the following: </p>
<ol>
<li>$\{y +4 = 3x\}$ z := y + 4 $\{z = 3x\}$ by (Axiom of Asignment)</li>
<li>$\{x + 2 + 4 = 3x\}$ y := x + 2 $\{y + 4 = 3x\}$ by (Axiom of Assignment)</li>
<li>$\{x + 2 + 4 = 3x\}$ y := x + 2; z := y + 4 $\{z = 3x\}$ by 1, 2 and (Concate Rule)
<li>$\models x + 2 + 4 = 3x \implies x = 3$ by (Theory of Natural Number)</li>
<li>$\{x =3\}$ y := x + 2; z := y + 4 $\{ z = 3x \}$ by 3,4 and (Consequence Rule)
<span class="qed">$\Box$</span>
</li>
</ol>
<h2>Weakest Precondition</h2>
<p>
Now that we have a formal deductive system to prove a program. However, to prove  prove programs we need to create precondition to satisfy the post condition.
</p>
<p>
To tackle this task, Dijkstra defined <em>weakest precondition</em> in his book &ldquo; A discipline of programming&rdquo; <a href="dijkstra">(Dijkstra 1976)</a> 
</p>
<p>
Weakest Precondition is a function from program $S$, postcondition $Q$ to pre condition $P$ where the precondition $P$ verify the post condition $Q$ on the program $S$.
</p>
<div class="definition" text="Weakest Precondition (wp)">
<p>
Weakest precondition $wp: S \times Q \rightarrow P$ is a function which satisfies 
$\vdash \{w(S,Q)\} S \{Q\}$ that is defined as follows:
</p>
\begin{array}{ll}
&wp(\text{skip}, Q) = Q,\\
&wp(\text{x=f}, Q) = Q[f/x],\\
&wp(s_1;s_2, Q) = wp(s_1, wp(s_2, Q)), \\
&wp(\text{if b then A else B}, Q) = (b \implies wp(A, Q)) \wedge (\neg b \implies wp(B, Q)),  \\
\end{array}
where $P$ is weaker than $P_1$ means $P_1 \implies P$.
</div>
<p>
The equation for "if b then A else B",
</p>
<p>
\begin{equation}
wp(\text{if b then A else B}, Q) = (b \implies wp(A, Q)) \wedge (\neg b \implies wp(B, Q))
\end{equation}
</p>
<p>
is also written as the follwoing format:
</p>
<p>
\begin{equation}
wp(\text{if b then A else B}, Q) = (b \wedge wp(A, Q)) \vee (\neg b \wedge wp(B, Q)).
\end{equation}
</p>
<p>
It is because of the following equality :
\begin{array}{ll}
(b \wedge P_0) \vee (\neg b \wedge P_1) &\Leftrightarrow \neg (b \wedge P_0) \wedge \neg (\neg b \wedge P_1)\\ 
&\Leftrightarrow (\neg b \vee P) \wedge (\neg\neg b \vee P_1)\\
&\Leftrightarrow (b \implies P) \wedge (\neg b \implies P_1).
\end{array}
</p>
<h2>Strongest Postcondition (sp)</h2>
<div class="definition" text="Strongest Postcondition (sp)">
<p>
Strongest postcondition $sp: S \times P \rightarrow Q$ is a function which satisfies $\vdash \{P\} S \{sp(S,P)\}$ such that:
\begin{array}{ll}
&sp(\text{skip}, P) = P, \\
&sp(\text{x=f}, P) = \exists v (x=f[v/x] \wedge P[v/x]),\\
&sp(s_1;s_2, P) = sp(s_2, sp(s_1, P)), \\
&sp(\text{if b then A else B}, P) = sp(A, P \wedge b) \vee sp(B, P \wedge \neg b), 
\end{array}
where $P$ is stronger than $P_1$ means $P \implies P_1$.
</p>
</div>
<h2>Symbolic Execution by sp</h2>
<p>
In program $S$, all the variables of $S$ and the relationship among them are expressed with the following logical form:
</p>
<p>
\begin{equation}
\exists x_1, \dots, x_n(X_1 = e_1 \wedge \dots \wedge X_n = e_n ∧ \phi)
\end{equation}
</p>
<p>
where $X_1,\dots,X_n$ are variable names in a program $S$, $x_1,\dots,x_n$ are logical (symbolic) variables, $e_1,\dots,e_n$ are values of $X_i$, and $\phi$ is the logical formulas which constraints the program variables. $e_i$ and $\phi$ may contain $x_i$ but must not contain program variables $X_i$.
<p>
<p>
<u>Example:</u>
<p>
\begin{equation}
\exists i,j (\text{I} = i ∧ \text{J} = j ∧ i < j)
\end{equation}
</p>
<p>
I and J are program variables. $i, j$ are logical symbolic variables, thus the above formula is logically equivalent to I $<$ J.
</p>
<p>
Also, in general, any predicate $P$ can be written with

\begin{equation}
\exists x_1 … x_n(X_1 = x_1 ∧ … ∧ X_n = x_n ∧ P[x_1,...,x_n/X_1,..., X_n])
\end{equation}

where $P[x_1,...,x_n/X_1,..., X_n]$ is corresponding to $\phi$.
</p>
<p>
Then, with the above setting,  $sp$ for $\text{X := E}$ will be,
\begin{array}{ll}
&sp(X_i := E, \, \exists x_1...x_n(X_1  = e_1 ∧ … ∧ X_n = e_n ∧ \phi)\\
&= \exists x_1...x_n(X_1=e_1 … ∧ X_i=E[e_1...e_n/X_1...X_n]∧...∧X_n=e_n∧\phi).
\end{array}
</p>
<p>
If $X_1,\dots,X_n, x_1,\dots,x_n$ are clear from the context, we simply writes:
\begin{array}{ll}
&sp(X_i = E, \, \exists \bar{x} (\bar{X} = \bar{e} \wedge \phi)\\
&= \exists \bar{x}(X_1 = e_1 \wedge \dots \wedge X_i = E[\bar{x}/\bar{e}] \wedge \dots \wedge X_n = e_n \wedge \phi
\end{array}
</p>
<h2>Automated Theorem Proving</h2>
<ul>
<li>Make examples of automated theorem proving using VC() on a program.
</ul>
<h2>References</h2>
<ol>
<li><a name="hoare">Hoare, C. A. R. An axiomatic basis for computer programming. Commun. ACM 12, 576–580 (1969)</a>
<li><a name="dijkstra">Dijkstra, E. W. A discipline of programming. vol. 613924118 (prentice-hall Englewood Cliffs, 1976)</a>
<li><a name="gordon_collavizza">Gordon, M. & Collavizza, H. Forward with Hoare. in Reflections on the Work of C.A.R. Hoare (eds. Roscoe, A. W., Jones, C. B. & Wood, K. R.) 101–121 (Springer London, 2010).</a>
</ol>
<hr>
<nav class="mb-3"><a href="index.html">Home</a> &gt; Hoare Logic</nav>
</div>
</body>
</html>
