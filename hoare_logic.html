<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="kmdtty.css">
<title>Hoare Logic</title>
<script src="kmdtty_mathjax_setting.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="container">
<h1>Notes on Hoare Logic</h1>
<h2>1. Introduction</h2>
<p>
Hoare Logic is a logic to prove progamming languages.
</p>
<p>
For example, imagine a C program which adding two integers.
</p>
<pre class="code">
int add(int x, int y) {
    int z = 0;
    z = x + y;
    return z;
}
</pre>
<p>
Then, <code>add(2,3)</code> returns $5$, <code>add(-100, 100)</code> returnds $0$.
</p>
<p>
To prove program behaviors, Hoare invented Hoare Triple in <a href="#hoare">(Hoare, 1969)</a>.
</p>
<div class="definition" text="Hoare Triple">
Hoare triple is a (P, S, Q) that is denoted:
\[\big\{P\big\}\, S\, \big\{Q\big\}\]
where $P$ is the precondition that is true before $S$ is executed, $S$ is a subset of program list, Q is the postcondition that is true after the $S$ are executed.
</div>
<p>For example, a hoare triple is formed as follows:</p>
<p>$\big\{x + y \Leftrightarrow 4\big\}$</p>
<p>
z = x + y;
</p>
<p>$\big\{z \Leftrightarrow 4\big\}$</p>
<p>
Here, the precondition $P$ is $x + y \Leftrightarrow 4$, and a program $S$ is <code>z = x + y</code>, and the postcondition $Q$ is $z \Leftrightarrow 4$. 
</p>
<p>
To derive $Q$ from the $P$ and $S$, we need a <em>deductive system</em>. Formal deductive systems are consists of <em>Axioms</em> and <em>Rule</em>, so let's start to consider its axioms with analyzing the programs.
</p>
<p>
When assigning a value f into variable x, <code>x=f</code>, what happened to the precondition and post condition? In Hoare Triple, we think the pre-condition from the post-condition. We are reasoning from backward. So what pre-condition we need for <code>x=f</code> $\{Q\}$? Since in $Q$, the variable <code>x</code> is replaced with <code>f</code>, the precondition $P$ must be $Q[f/x]$.
</p>
<p>
The most simple example is:
</p>
<pre class="code">
{P?}
<code>x = f</code>
{x = f}
</pre>
<p>
The $P$ must be $Q[f/x]$ so $f = f$. WIth this analysis we defines the following axiom.
</p>

<div class="definition" text="Axiom of Assignment">
\begin{equation}
\frac{}{
\big\{ Q[\text{f/x}] \big\}\,\,
\text{x = f}\,\,
\big\{Q\big\}
}
\end{equation}
where <b>x</b> is a variable of a program, <b>f</b> is a expression of a program, and $Q[\text{f/x}]$ denotes a replacement all occurense of <b>f</b> in $Q$ with <b>x</b> .
</div>
<p>
Having Axiom of Assignment, now we can prove the following Hoare Triple.</p>
<p>\begin{equation*}
\big\{x + y \Leftrightarrow 4\big\} \,
\text{z = x + y;} \,
\big\{z \Leftrightarrow 4\big\}
\end{equation*}
</p>
<p>
$z \Leftrightarrow 4$ can be replaced with $(z \Leftrightarrow 4)[\text{x+y/z}]$ by Axiom of Assignment, then we immediately get $ x + y \Leftrightarrow 4$.
<span class="qed">$\Box$</span>
</p>
<div class="definition" text="Concate Rule">
\begin{equation}
\frac{
\big\{P\big\} A \big\{P_1\big\} \, \, \, \, \,
\big\{P_1\big\} B \big\{Q\big\}
}{
\big\{ P \big\} \,
\text{A; B} \,
\big\{ Q \big\}
}
\end{equation}
</div>
<div class="definition" text="If Rule">
\begin{equation}
\frac{
  \big\{ b \wedge P\big\}  s_1 \big\{ Q\big\} \, \, \, \, \, \, \,
  \big\{ \neg b \wedge P\big\}  s_2 \big\{ Q\big\}
  }
  {
\big\{ P \big\}  \, \,
\text{if (b) \{$s_1$\} else \{ $s_2$ \}  } \, \,
\big\{ Q \big\}
}
\end{equation}
</div>
<div class="definition" text="Consequence Rule">
\begin{equation}
\frac{\models P_0 \implies P \, \, \, \, \,
\models Q_0 \implies Q \, \, \, \, \,
\big\{ P_0 \big\} S \big\{ Q_0\big\}
}
{\big\{ P \big\} S \big\{ Q\big\}}
\end{equation}
</div>
<!--
<div class="definition" text="Loop Rule">
\begin{equation}
(TBA)
\end{equation}
</div>
-->
<p>
Example:
</p>
<h2>Weakest Precondition</h2>
<p>
Now that we have a formal deductive system to prove a program. However, to prove  prove programs we need to create precondition to satisfy the post condition.
</p>
<p>
To tackle this task, Dijkstra defined <em>weakest precondition</em> in his book &ldquo; A discipline of programming&rdquo; <a href="dijkstra">(Dijkstra 1976)</a> 
</p>
<p>
Weakest Precondition is a function from program $S$, postcondition $Q$ to pre condition $P$ where the precondition $P$ verify the post condition $Q$ on the program $S$.
</p>
<div class="definition" text="Weakest Precondition (wp)">
<p>
Weakest precondition function $wp: S \times Q \times P$ is defined as follows:
</p>
\begin{array}{ll}
&wp(\text{skip}, Q) = Q\\
&wp(\text{x=f}, Q) = Q[f/x]\\
&wp(s_1;s_2, Q) = wp(s_1, wp(s_2, Q)) \\
&wp(\text{if b then A else B}, Q) = (b \wedge wp(A, Q)) \vee (\neg b \wedge wp(B, Q))  \\
\end{array}
</div>
<p>
Then reasoning a post condition $Q$ of program $S$ becomes a task executing:
<p>
<div>
\begin{equation}
\mathcal{T} \models \{wp(S, Q)\} \, \, S \, \, \{Q\}
\end{equation}
</div>
<p>
under certain theory $\mathcal{T}$.
</p>
<p>
Example:
</p>
<h2>Verification Condition</h2>
<ul>
<li>Construct VC()</li>
</ul>
<h2>Automated Theorem Proving</h2>
<ul>
<li>Make examples of automated theorem proving using VC() on a program.
</ul>
<h2>References</h2>
<ol>
<li><a name="hoare">Hoare, C. A. R. An axiomatic basis for computer programming. Commun. ACM 12, 576â€“580 (1969)</a>
<li><a name="dijkstra">Dijkstra, E. W. A discipline of programming. vol. 613924118 (prentice-hall Englewood Cliffs, 1976)</a>
</ol>
<hr>
<nav class="mb-3"><a href="index.html">Home</a> &gt; Hoare Logic</nav>
</div>
</body>
</html>
