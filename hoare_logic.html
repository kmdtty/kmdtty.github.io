<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="kmdtty.css">
<title>Hoare Logic</title>
<script src="kmdtty_mathjax_setting.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="container">
<h1>Notes on Hoare Logic</h1>
<h2>1. Introduction</h2>
<p>
Hoare Logic is a logic to prove progamming languages.
</p>
<p>
For example, imagine a C like imerative program which adding two integers <code>x</code>, <code>y</code>.
</p>
<pre class="code">
z := x + y
</pre>
<p>
This program looks obvious, but if we need to prove this program behavior, how to do it? To answer this question, Hoare invented Hoare Triple in <a href="#hoare">(Hoare, 1969)</a>.
</p>
<div class="definition" text="Hoare Triple">
Hoare triple is a (P, S, Q) that is denoted:
\[\{P\}\, S\, \{Q\}\]
where $P$ is the precondition that is true before $S$ is executed, $S$ is a subset of program list, Q is the postcondition that is true after the $S$ are executed.
</div>
<p>For example, a hoare triple is formed as follows:</p>
<p>$\{x + y = 4\}$</p>
<p>
z := x + y
</p>
<p>$\{z = 4\}$</p>
<p>
Here, the precondition $P$ is $x + y = 4$, and a program $S$ is <code>z := x + y</code>, and the postcondition $Q$ is $z = 4$. 
</p>
<p>
To derive a conclusion from premises, we need a <em>deductive system</em>. Formal deductive systems are consists of <em>Axioms</em> and <em>Rule</em>. To derive $Q$ from $P$ and $S$, let's consider the axiom and rules with analyzing the programs.
</p>
<p>
When assigning a value f into variable x, <code>x=f</code>, what happened to the precondition and post condition? In Hoare Triple, we think the pre-condition from the post-condition. We are reasoning from backward. So what pre-condition we need for <code>x=f</code> $\{Q\}$? Since in $Q$, the variable <code>x</code> is replaced with <code>f</code>, the precondition $P$ must be $Q[f/x]$.
</p>
<p>
The most simple example is:
</p>
<pre class="code">
{P?}
<code>x := f</code>
{x = f}
</pre>
<p>
The the precondition $P$ must be $Q[f/x]$ so here it is $f = f$. 
</p>
<p>
With this analysis we defines the following axiom.
</p>

<div class="definition" text="Axiom of Assignment">
\begin{equation}
\frac{}{
\{ Q[\text{f/x}] \}\,\,
\text{x := f}\,\,
\{Q\}
}
\end{equation}
where <b>x</b> is a variable of a program, <b>f</b> is a expression of a program, and $Q[\text{f/x}]$ denotes a replacement all occurense of <b>f</b> in $Q$ with <b>x</b> .
</div>
<p>
Having Axiom of Assignment, now we can prove the following Hoare Triple.</p>
<p>\begin{equation*}
\{x + y = 4\} \,
\text{z := x + y;} \,
\{z = 4\}
\end{equation*}
</p>
<p>
$z = 4$ can be replaced with $(z = 4)[\text{x+y/z}]$ by Axiom of Assignment, then we immediately get $ x + y = 4$.
<span class="qed">$\Box$</span>
</p>
<p>
Likewise, we define these deductive rules. Before defining all the remaining rules, we first need the the target programming language specification.
</p>
<div class="definition" text="Target Programming Language">
\begin{array}{lll}
&e :=& x \mid n  \mid e + e \mid e * e\\
&b :=& \text{true } \mid \text{ false } \mid e \lt e \mid e \gt e \mid e == e \mid \text{not } b \mid b \text{ and } b \mid b \text{ or } b \\
&s :=& \text{skip } \mid \, s;s \mid x = e \mid \text{ if b then $c$ else $c$} 
\end{array}
<p>
where x is a meta charactor of variables, n is a meta charactor of number, s is programs.
</p>
</div>
<p>
With the above syntax all those are programs:
</p>
<ul>
<li><code>if x &gt; y then y = x else x = y</code>
<li><code>skip; skip; skip</code>
<li><code>x := 1; y := x + 2; z := y + 3</code>
</ul>
<p>
Now we have defined the syntax of target program. Next, we defines all remaining rules.
</p>
<div class="definition" text="Concate Rule">
\begin{equation}
\frac{
\{P\} A \{P_1\} \, \, \, \, \,
\{P_1\} B \{Q\}
}{
\{ P \} \,
\text{A; B} \,
\{ Q \}
}
\end{equation}
</div>
<div class="definition" text="If Rule">
\begin{equation}
\frac{
  \{ b \wedge P\}  s_1 \{ Q\} \, \, \, \, \, \, \,
  \{ \neg b \wedge P\}  s_2 \{ Q\}
  }
  {
\{ P \}  \, \,
\text{if (b) \{$s_1$\} else \{ $s_2$ \}  } \, \,
\{ Q \}
}
\end{equation}
</div>
<div class="definition" text="Consequence Rule">
\begin{equation}
\frac{\models P_0 \implies P \, \, \, \, \,
\models Q_0 \implies Q \, \, \, \, \,
\{ P_0 \} S \{ Q_0\}
}
{\{ P \} S \{ Q\}}
\end{equation}
</div>
<!--
<div class="definition" text="Loop Rule">
\begin{equation}
(TBA)
\end{equation}
</div>
-->
<p>
Example:
</p>
<p>
Let a hoare triple be, $\{x = 3\}$ y := x + 2; z := y + 4  $\{z = 3x\}$, a proof with Hoare Logic is the following: </p>
<ol>
<li>$\{y +4 = 3x\}$ z := y + 4 $\{z = 3x\}$ by (Axiom of Asignment)</li>
<li>$\{x + 2 + 4 = 3x\}$ y := x + 2 $\{y + 4 = 3x\}$ by (Axiom of Assignment)</li>
<li>$\{x + 2 + 4 = 3x\}$ y := x + 2; z := y + 4 $\{z = 3x\}$ by 1, 2 and (Concate Rule)
<li>$\models x + 2 + 4 = 3x \implies x = 3$ by (Theory of Natural Number)</li>
<li>$\{x =3\}$ y := x + 2; z := y + 4 $\{ z = 3x \}$ by 3,4 and (Consequence Rule)
<span class="qed">$\Box$</span>
</li>
</ol>
<h2>Weakest Precondition</h2>
<p>
Now that we have a formal deductive system to prove a program. However, to prove  prove programs we need to create precondition to satisfy the post condition.
</p>
<p>
To tackle this task, Dijkstra defined <em>weakest precondition</em> in his book &ldquo; A discipline of programming&rdquo; <a href="dijkstra">(Dijkstra 1976)</a> 
</p>
<p>
Weakest Precondition is a function from program $S$, postcondition $Q$ to pre condition $P$ where the precondition $P$ verify the post condition $Q$ on the program $S$.
</p>
<div class="definition" text="Weakest Precondition (wp)">
<p>
Weakest precondition $wp: S \times Q \rightarrow P$ is a function where the $P$ satisfies $\vdash \{P\} S \{Q\}$ that is defined as follows:
</p>
\begin{array}{ll}
&wp(\text{skip}, Q) = Q,\\
&wp(\text{x=f}, Q) = Q[f/x],\\
&wp(s_1;s_2, Q) = wp(s_1, wp(s_2, Q)), \\
&wp(\text{if b then A else B}, Q) = (b \wedge wp(A, Q)) \vee (\neg b \wedge wp(B, Q)),  \\
\end{array}
where $P$ is weaker than $P_1$ means $P_1 \implies P$.
</div>

<h2>Verification Condition</h2>
<p>
With the definition of $wp$, reasoning a hoare triple on program $\{P\} S \{Q\}$ becomes a task that is constructing:
<p>
<div>
\begin{equation}
\mathcal{T} \vdash \{P \implies wp(S, Q)\} \, \, S \, \, \{Q\}
\end{equation}
</div>
<p>
under certain theory $\mathcal{T}$.
</p>
<div class="definition" text="Verification condition (vc)">
\begin{array}{ll}
&vc(\{P\} S \{Q\}) = P \implies wp(S, Q)  \\
\end{array}
</div>
<p>
Example:
</p><h2>Automated Theorem Proving</h2>
<ul>
<li>Make examples of automated theorem proving using VC() on a program.
</ul>
<h2>References</h2>
<ol>
<li><a name="hoare">Hoare, C. A. R. An axiomatic basis for computer programming. Commun. ACM 12, 576â€“580 (1969)</a>
<li><a name="dijkstra">Dijkstra, E. W. A discipline of programming. vol. 613924118 (prentice-hall Englewood Cliffs, 1976)</a>
</ol>
<hr>
<nav class="mb-3"><a href="index.html">Home</a> &gt; Hoare Logic</nav>
</div>
</body>
</html>
